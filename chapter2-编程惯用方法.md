## assert
1. 断言说明
    * ``__debug__``默认是True,只读不可修改
    * 断言有代价,影响性能.pyhon没有严格定义调试和发布模式.通过``-O``参数禁用断言,但这种方式并不优化字节码,而是忽略断言相关语句
2. 断言使用注意事项
    * 不要滥用,应该使用在正常逻辑不可达的地方或正常情况下总是为真的情况
    * 异常处理优于断言
    * 不要用断言判断用户输入,应该用条件判断+错误提示
    * 函数调用,需要确认返回值是否合理的时候可以使用断言
    * 但条件是业务逻辑继续下去的先决条件时可以使用断言

## 数值交换不使用中间变量
```python
x, y = y, x
```
* 不借助中间变量,代码更简洁,性能更好
* python表达式一般从左到右计算,但是表达式赋值先右后左
* 字节码分析参照书本(P22)

## Lazy evaluation(延迟计算)
1. 避免不必要计算
    * if x and y中,x为True不计算y.
    * if x or y中,x为False不计算y.
    * 根据x和y的值的可能性排序变量在if语句中位置
2. 节省空间,使无限循环变成可能
    * 生成式表达式``yield``

## 枚举
1. 使用类属性
    ```python
    class Seasons:
        Spring, Summer, Autumn, Winter = range(4)
     ```
2. 借助函数
    P25
3. 使用``collections.namedtuple``.

## 不使用type进行类型检查
* 动态型强类型脚本语言,运行时自动进行类型检查并根据需要隐式转换
* 通过异常处理类型
* 新式类和旧式类type返回结果又差异
* 用户自定义类型type不能准确返回结果
* 可以通过工厂函数或者isinstance()约束用户输入类型和我们期望一致

## 尽量转换为浮点类型再做除法
* 地板除和真实除法的区别和使用的地方
* 浮点数不用与判断,因为不精确

## eval()
* 防止eval()注入
* 如果使用对象不是信任的,避免使用eval(),在需要使用的地方用安全性更好的ast.literal_eval代替

